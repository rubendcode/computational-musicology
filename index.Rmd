---
title: "Corpus Ruben Dijksma"
output: 
  flexdashboard::flex_dashboard:
    storyboard: true
    self_contained: false
    source: https://github.com/rubendcode/computational-musicology/blob/main/index.Rmd
    css: css_file.css
    theme:
      heading_font:
        google: 
          family: Rajdhani
          wght: 700
      base_font:
        google: Fira Sans
      code_font:
        google: Fira Mono
      bg: "#FFFFFF"
      fg: "#212529" 
      primary: "#2b2bee"
      secondary: "#39d7b8"
      success: "#39d7b8"
      danger: "#fa5577"
      warning: "#ffb14c"
      info: "#0cc7f1"
date: "2024-02-23"
---

```{r setup, include=FALSE}
library(tidyverse)
library(tidymodels)
library(plotly)
library(heatmaply)
library(protoclust)
library(cowplot)
library(spotifyr)
library(htmltools)
library(compmus)
library(gridExtra)
library(cowplot)

knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
```

### Introduction

When do we call a pop song an indiepop song? Last month, the famous 2000’s pop song ‘Murder on the Dancefloor’ by Sophie Ellis-Bextor has been rediscovered by TikTok after the movie Saltburn came out. The song was covered by ‘indie-pop’ duo Royel Otis. After the cover the song turned into a timeless indiepop song with sounds from the 2010’s. As a musician, myself heavily inspired by the indie-pop style I am more than interested to discover what musical components make a regular pop song differ from an indie-pop song that makes me and many others feel a certain nostalgic way. My corpus is genre-based but I plan to analyze artists, songs, playlists, and charts with this research question. I hope to be able to discover when Spotify recognizes songs within Spotify as ‘indie-pop’, ‘pop’, or maybe in some cases both. I am not sure how deep we can analyze the song's components (chords, scales etc.) or just the metadata around it. I plan to get the tracks from playlists as “Indie Pop”, “Indie Pop Hits” and “Pop Rising” curated by Spotify. As specific tracks I want to look at current “pop” hits such as “Flowers” by Miley Cyrus and “Greedy” by Tate McRae and current “indie pop” hits such as the Murder On The Dancefloor cover by Royel Otis and a classic as Kilby Girl by The Backseat Lovers.

------------------------------------------------------------------------

This index will show multiple graphs and discussions about the difference in genre.

### Energy vs Acousticness

Week 7 assignment:

For the first graphs I made 2 graphs with the energy on the X axis and the acousticness on the Y axis. I used an indie pop and pop party playlist with both graphs showing that indie pop is more acoustic and pop more energetic. These graphs already show an interesting contrast in the genres.

```{r echo=FALSE, out.width = '100%', fig.width = 4, fig.height = 6}
library(tidyverse)
library(spotifyr)

# Fetch audio features for playlists
indiepop <- get_playlist_audio_features("", "37i9dQZF1DWWEcRhUVtL8n?si=8549c3d965e4458c&nd=1&dlsi=7e635eb660464a36")
pop <- get_playlist_audio_features("", "37i9dQZF1DWXti3N4Wp5xy?si=e0a5344cb1b545c5&nd=1&dlsi=61886b9565ee4c74")

# Combine playlists into a single data frame
music <- bind_rows(
  indiepop %>% mutate(category = "Indie Pop Playlist"),
  pop %>% mutate(category = "Pop Playlist")
)

# Create the ggplot object
ggplot_obj <- ggplot(music, aes(x = energy, y = acousticness)) +
  geom_point(aes(color = category), alpha = 0.7) +
  facet_wrap(~category) +
  labs(x = "Energy", y = "Acousticness") +
  theme_minimal()

# Render the plot using ggplotly to ensure proper display
div(
  ggplotly(ggplot_obj),
  style = "width: 900px; height: 600px; overflow: scroll;"
)

```

------------------------------------------------------------------------

For these graphs I used these playlists at the moment:

```{r echo=FALSE}
library(htmltools)

div(
  HTML('<iframe src="https://open.spotify.com/embed/playlist/37i9dQZF1DWWEcRhUVtL8n?utm_source=generator" width="100%" height="390" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>')
)

div(
  HTML('<iframe src="https://open.spotify.com/embed/playlist/37i9dQZF1DWXti3N4Wp5xy?utm_source=generator" width="100%" height="390" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>')
)

```

### Chromagrams Murder On The Dancefloor

```{r chromagrams, echo=FALSE}


library(cowplot)

royelotis <- get_tidy_audio_analysis("1swz9stsbG1p34SJHJqiww") |>
  select(segments) |>
  unnest(segments) |>
  select(start, duration, pitches) |>
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) |>
  compmus_gather_chroma() |> 
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = pitch_class,
      fill = value
    )
  ) +
  geom_tile() +
  labs(title = "Royel Otis Murder On The Dancefloor", x = "Time (s)", y = NULL, fill = "Magnitude") +
  theme_minimal() +
  scale_fill_viridis_c()

Sophie <- get_tidy_audio_analysis("4tKGFmENO69tZR9ahgZu48") |>
  select(segments) |>
  unnest(segments) |>
  select(start, duration, pitches) |>
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) |>
  compmus_gather_chroma() |> 
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = pitch_class,
      fill = value
    )
  ) +
  geom_tile() +
  labs(title = "Sophie Ellis-Bextor Murder On The Dancefloor", x = "Time (s)", y = NULL, fill = "Magnitude") +
  theme_minimal() +
  scale_fill_viridis_c()


# Arrange the plots in a grid layout with synchronized x-axis scales
grid <- plot_grid(royelotis, Sophie, nrow = 2, align = "hv", scale = c(1, 1)) # Adjust the relative width here

# Display the combined plot
grid


```

------------------------------------------------------------------------

The chromagrams show that both tracks are in the same key. I think it is interesting to see that the E note is really present in the Royel Otis (indie) version and less in the version from Sophie. The C# is being played more (as a harmonic I assume) in the Sophie version.

### Timbre Graphs

```{r timbres, echo=FALSE}

royelotis_timbre <-
  get_tidy_audio_analysis("1swz9stsbG1p34SJHJqiww") |> # Change URI.
  compmus_align(bars, segments) |>                     # Change `bars`
  select(bars) |>                                      #   in all three
  unnest(bars) |>                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  ) |>
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  )

royelotis_timbre |>
  compmus_self_similarity(timbre, "cosine") |> 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  labs(title = "Royel Otis Murder On The Dancefloor", x = "Time (s)", y = NULL, fill = "Magnitude") +
  coord_fixed() +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "", y = "")


sophie_timbre <-
  get_tidy_audio_analysis("4tKGFmENO69tZR9ahgZu48") |> # Change URI.
  compmus_align(bars, segments) |>                     # Change `bars`
  select(bars) |>                                      #   in all three
  unnest(bars) |>                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  ) |>
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  )

sophie_timbre |>
  compmus_self_similarity(timbre, "cosine") |> 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  labs(title = "Sophie Ellis-Bextor Murder On The Dancefloor", x = "Time (s)", y = NULL, fill = "Magnitude") +
  coord_fixed() +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "", y = "")


library(cowplot)

# Define the dimensions of the plot
plot_width <- 800
plot_height <- 600

# Define a theme with plot margin
theme_with_margin <- theme(
  plot.margin = margin(5, 5, 5, 5)
)

# Arrange the timbre graphs in a grid layout
grid <- plot_grid(royelotis_timbre, sophie_timbre, ncol = 2)

# Display the combined plot
grid
```

------------------------------------------------------------------------

These show that there is 'more' timbre in the original version from Sophie.

### Chordograms of Corpus

```{r}
circshift <- function(v, n) {
  if (n == 0) v else c(tail(v, n), head(v, -n))
}

#      C     C#    D     Eb    E     F     F#    G     Ab    A     Bb    B
major_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    0,    0)
minor_chord <-
  c(   1,    0,    0,    1,    0,    0,    0,    1,    0,    0,    0,    0)
seventh_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    1,    0)

major_key <-
  c(6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88)
minor_key <-
  c(6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17)

chord_templates <-
  tribble(
    ~name, ~template,
    "Gb:7", circshift(seventh_chord, 6),
    "Gb:maj", circshift(major_chord, 6),
    "Bb:min", circshift(minor_chord, 10),
    "Db:maj", circshift(major_chord, 1),
    "F:min", circshift(minor_chord, 5),
    "Ab:7", circshift(seventh_chord, 8),
    "Ab:maj", circshift(major_chord, 8),
    "C:min", circshift(minor_chord, 0),
    "Eb:7", circshift(seventh_chord, 3),
    "Eb:maj", circshift(major_chord, 3),
    "G:min", circshift(minor_chord, 7),
    "Bb:7", circshift(seventh_chord, 10),
    "Bb:maj", circshift(major_chord, 10),
    "D:min", circshift(minor_chord, 2),
    "F:7", circshift(seventh_chord, 5),
    "F:maj", circshift(major_chord, 5),
    "A:min", circshift(minor_chord, 9),
    "C:7", circshift(seventh_chord, 0),
    "C:maj", circshift(major_chord, 0),
    "E:min", circshift(minor_chord, 4),
    "G:7", circshift(seventh_chord, 7),
    "G:maj", circshift(major_chord, 7),
    "B:min", circshift(minor_chord, 11),
    "D:7", circshift(seventh_chord, 2),
    "D:maj", circshift(major_chord, 2),
    "F#:min", circshift(minor_chord, 6),
    "A:7", circshift(seventh_chord, 9),
    "A:maj", circshift(major_chord, 9),
    "C#:min", circshift(minor_chord, 1),
    "E:7", circshift(seventh_chord, 4),
    "E:maj", circshift(major_chord, 4),
    "G#:min", circshift(minor_chord, 8),
    "B:7", circshift(seventh_chord, 11),
    "B:maj", circshift(major_chord, 11),
    "D#:min", circshift(minor_chord, 3)
  )

key_templates <-
  tribble(
    ~name, ~template,
    "Gb:maj", circshift(major_key, 6),
    "Bb:min", circshift(minor_key, 10),
    "Db:maj", circshift(major_key, 1),
    "F:min", circshift(minor_key, 5),
    "Ab:maj", circshift(major_key, 8),
    "C:min", circshift(minor_key, 0),
    "Eb:maj", circshift(major_key, 3),
    "G:min", circshift(minor_key, 7),
    "Bb:maj", circshift(major_key, 10),
    "D:min", circshift(minor_key, 2),
    "F:maj", circshift(major_key, 5),
    "A:min", circshift(minor_key, 9),
    "C:maj", circshift(major_key, 0),
    "E:min", circshift(minor_key, 4),
    "G:maj", circshift(major_key, 7),
    "B:min", circshift(minor_key, 11),
    "D:maj", circshift(major_key, 2),
    "F#:min", circshift(minor_key, 6),
    "A:maj", circshift(major_key, 9),
    "C#:min", circshift(minor_key, 1),
    "E:maj", circshift(major_key, 4),
    "G#:min", circshift(minor_key, 8),
    "B:maj", circshift(major_key, 11),
    "D#:min", circshift(minor_key, 3)
  )

royel_otis <-
  get_tidy_audio_analysis("1swz9stsbG1p34SJHJqiww") |>
  compmus_align(sections, segments) |>
  select(sections) |>
  unnest(sections) |>
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )

royel_otis |> 
  compmus_match_pitch_template(
    chord_templates,         # Change to chord_templates if descired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) |>
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
    geom_tile() +
  labs(title = "Chordogram Royel Otis Murder On The Dancefloor", x = "Time (s)", y = NULL, fill = "Magnitude") +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "")

sophie <-
  get_tidy_audio_analysis("4tKGFmENO69tZR9ahgZu48") |>
  compmus_align(sections, segments) |>
  select(sections) |>
  unnest(sections) |>
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )

sophie |> 
  compmus_match_pitch_template(
    chord_templates,         # Change to chord_templates if descired
    method = "euclidean",  # Try different distance metrics
    norm = "manhattan"     # Try different norms
  ) |>
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  labs(title = "Chordogram Sophie Ellis-Bextor Murder On The Dancefloor", x = "Time (s)", y = NULL, fill = "Magnitude") +
  scale_fill_viridis_c(guide = "none") +
  theme_minimal() +
  labs(x = "Time (s)", y = "")


```

------------------------------------------------------------------------

The chordogram is not able to recognise the chords in the indiepop song as well as in the pop song.

### Playlist SD Comparisons

```{r}
# Load necessary libraries
library(dplyr)
library(ggplot2)
# Define function to fetch playlist audio features and add audio analysis
get_and_analyze_playlist <- function(playlist_id, playlist_name) {
  playlist_features <- get_playlist_audio_features("thesoundsofspotify", playlist_id) %>%
    slice(1:30) %>%
    add_audio_analysis() %>%
    mutate(playlist_name = playlist_name)
  return(playlist_features)
}

# Fetch audio features and analyze playlists for pop and indiepop
pop <- get_and_analyze_playlist("37i9dQZF1DWXti3N4Wp5xy", "Pop")
indiepop <- get_and_analyze_playlist("37i9dQZF1DWWEcRhUVtL8n", "Indie Pop")

# Combine playlists into one dataframe
combined <- bind_rows(pop, indiepop)

# Analyze and compare audio features across the playlists
# Calculate standard deviation for loudness, tempo, and duration
summary_comparison <- combined %>%
  group_by(playlist_name) %>%
  summarise(
    mean_loudness = mean(loudness),
    sd_loudness = sd(loudness),
    mean_tempo = mean(tempo),
    sd_tempo = sd(tempo),
    mean_duration = mean(duration),
    sd_duration = sd(duration)
  )

# Reshape data to long format for easier plotting
summary_comparison_long <- summary_comparison %>%
  pivot_longer(cols = c(mean_loudness, mean_tempo, mean_duration),
               names_to = "Variable",
               values_to = "Mean") %>%
  mutate(SD = ifelse(Variable == "mean_loudness", sd_loudness,
                     ifelse(Variable == "mean_tempo", sd_tempo, sd_duration)))

# Plot grouped bar chart for comparison
ggplot(summary_comparison_long, aes(x = playlist_name, y = Mean, fill = Variable)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9), width = 0.6) +
  geom_errorbar(aes(ymin = Mean - SD, ymax = Mean + SD), position = position_dodge(width = 0.9), width = 0.2) +
  labs(
    x = "Playlist",
    y = "Value",
    title = "Comparison of Mean and Standard Deviation for Loudness, Tempo, and Duration"
  ) +
  scale_fill_manual(values = c("mean_loudness" = "skyblue", "mean_tempo" = "salmon", "mean_duration" = "lightgreen")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  guides(fill = guide_legend(title = "Variable"))


#Keys of the playlists

# Define function to fetch playlist audio features and add audio analysis
get_and_analyze_playlist <- function(playlist_id, playlist_name) {
  playlist_features <- get_playlist_audio_features("thesoundsofspotify", playlist_id) %>%
    slice(1:30) %>%
    add_audio_analysis() %>%
    mutate(playlist_name = playlist_name)
  return(playlist_features)
}


# Function to extract keys from audio features
extract_keys <- function(audio_features) {
  # Extracting keys (assuming keys are available in the 'key' column)
  keys <- audio_features$key
  return(keys)
}

# Fetch audio features and analyze playlists for pop and indiepop
indiepop <- get_playlist_audio_features("", "37i9dQZF1DWWEcRhUVtL8n?si=8549c3d965e4458c&nd=1&dlsi=7e635eb660464a36")
pop <- get_playlist_audio_features("", "37i9dQZF1DWXti3N4Wp5xy?si=e0a5344cb1b545c5&nd=1&dlsi=61886b9565ee4c74")
# Extract keys for each playlist
pop_keys <- extract_keys(pop)
indiepop_keys <- extract_keys(indiepop)

# Calculate frequency of keys for each playlist
pop_key_freq <- table(pop_keys)
indiepop_key_freq <- table(indiepop_keys)

# Combine frequency tables into a single dataframe
keys_df <- data.frame(
  Key = factor(names(pop_key_freq), levels = names(pop_key_freq)),
  Pop_Frequency = as.numeric(pop_key_freq),
  IndiePop_Frequency = as.numeric(indiepop_key_freq)
)

# Reshape data to long format
keys_df_long <- keys_df %>%
  pivot_longer(cols = c(Pop_Frequency, IndiePop_Frequency),
               names_to = "Playlist",
               values_to = "Frequency")

# Manually adding a data point with both categories to ensure legend shows up
keys_df_long <- rbind(keys_df_long, data.frame(Key = levels(keys_df_long$Key)[1], Playlist = "Pop", Frequency = 0),
                                      data.frame(Key = levels(keys_df_long$Key)[1], Playlist = "Indie Pop", Frequency = 0))

# Plot histogram of keys for different groups
ggplot(keys_df_long, aes(x = Key, y = Frequency, fill = Playlist)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
  labs(
    x = "Key",
    y = "Frequency",
    title = "Histogram of Keys for Pop and Indie Pop Playlists"
  ) +
  scale_fill_manual(values = c("Pop" = "skyblue", "Indie Pop" = "salmon"),
                    guide = guide_legend(title = "Playlist")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_x_discrete(labels = c("C", "C♯", "D", "D♯", "E", "F", "F♯", "G", "G♯", "A", "A♯", "B"))

```



### Conclusion & Discussion

```{r }
```
